// Standard Library Strings Module
// Provides comprehensive string manipulation capabilities

fn split(text: str, delimiter: str): [str] {
    // Split string by delimiter
    // Note: This is a simplified implementation
    // A full implementation would need proper string parsing
    var result: [str] = [];
    if (text == "") {
        return result;
    }
    
    // For now, return the original string as single element
    // This would need proper implementation in the VM
    result[0] = text;
    return result;
}

fn join_strings(strings: [str], separator: str): str {
    // Join strings with separator
    if (strings.length == 0) {
        return "";
    }
    
    var result: str = strings[0];
    var i: int = 1;
    while (i < strings.length) {
        result = result + separator + strings[i];
        i = i + 1;
    }
    return result;
}

fn trim(text: str): str {
    // Remove leading and trailing whitespace
    // Note: This would need proper implementation in the VM
    return text;
}

fn trim_start(text: str): str {
    // Remove leading whitespace
    return text;
}

fn trim_end(text: str): str {
    // Remove trailing whitespace
    return text;
}

fn to_upper(text: str): str {
    // Convert to uppercase
    // Note: This would need proper implementation in the VM
    return text;
}

fn to_lower(text: str): str {
    // Convert to lowercase
    return text;
}

fn contains_substring(text: str, substring: str): bool {
    // Check if text contains substring
    // Note: This would need proper implementation in the VM
    return false;
}

fn starts_with(text: str, prefix: str): bool {
    // Check if text starts with prefix
    return false;
}

fn ends_with(text: str, suffix: str): bool {
    // Check if text ends with suffix
    return false;
}

fn replace(text: str, old: str, new: str): str {
    // Replace all occurrences of old with new
    return text;
}

fn substring(text: str, start: int, end: int?): str? {
    // Safe substring extraction
    if (start < 0) {
        return nil;
    }
    // Note: This would need proper implementation
    return text;
}

fn char_at(text: str, index: int): str? {
    // Get character at index
    if (index < 0) {
        return nil;
    }
    return nil;
}

fn index_of(text: str, substring: str): int? {
    // Find first occurrence of substring
    return nil;
}

fn last_index_of(text: str, substring: str): int? {
    // Find last occurrence of substring
    return nil;
}

// String builder type for efficient concatenation
type StringBuilder = {
    parts: [str],
    total_length: int
};

fn new_builder(): StringBuilder {
    return StringBuilder {
        parts: [],
        total_length: 0
    };
}

fn append_to_builder(self: StringBuilder, text: str): nil {
    // Add text to parts array
    // Note: This would need proper implementation to modify the array
    self.total_length = self.total_length + text.length;
}

fn builder_to_string(self: StringBuilder): str {
    // Efficiently concatenate all parts
    var result: str = "";
    var i: int = 0;
    while (i < self.parts.length) {
        result = result + self.parts[i];
        i = i + 1;
    }
    return result;
}