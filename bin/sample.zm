// sample.lm

// Luminar Programming Language
// Key Features:
// - Controlled Unsafe Operations

// ---------------------------------------------------
// Basic Syntax
// ---------------------------------------------------

// ---------------------------------------------------
// Core Type System
// ---------------------------------------------------

// === Primitive Types ===
type date = i64;
type numbers = u64;
type amount = f64;
type isTrue = bool;
type string = str;

// === Type Aliases ===
type Id = uint;
type Name = str;
type Age = uint;

// === Option Type ===
type Some = { kind: "Some", value: any };
type None = nil;  // Or: type None = { kind: "None" };

type Option = Some | None;

// Example usage:
// var maybeName: Option = { kind: "Some", value: "Alice" };
// var noValue: Option = nil;

// === Result Type ===
type Success = { kind: "Success", value: any };
type Error = { kind: "Error", message: any };

type Result = Success | Error;
type DictOfIntToFloat = { int: float };
type DictOfStrToInt = { string: int };
type ListOfString = [string];
type ListOfAny = [any];
type Channel = object;
type Atomic = object;
type ParsedResult = { data: string };
type StreamEvent = { raw: string, timestamp: date };
type ProcessedEvent = { cleaned: string, enriched: isTrue };

// ---------------------------------------------------
// Arithmetic and Logical Operations
// ---------------------------------------------------

print(10 + 5 * 2);                  
print((10 > 5) and (5 < 2));        
print("Hello, " + "Luminar!");      

// ---------------------------------------------------
// Loops
// ---------------------------------------------------

for (var i = 0; i < 10; i += 1) {
    print(i);
}

iter (i in 1..5) {
    print("Range iteration: {i}");
}

var fruits: ListOfString = ["Apple", "Banana", "Cherry"];
iter (fruit in fruits) {
    print(fruit);
}

var my_dict: DictOfStrToInt = { "a": 1, "b": 2, "c": 3 };
iter (key, value in my_dict) {
    print("{key}: {value}");
}

iter (x in 1..3) {
    iter (y in 1..2) {
        print("x: {x}, y: {y}");
    }
}

var count: int = 0;
while (count < 3) {
    print("Count: {count}");
    count += 1;
}

// ---------------------------------------------------
// Traits
// ---------------------------------------------------


@open
trait Hashable {
    fn hash() {
        // Empty implementation for trait method
        return 0;
    }
    
    fn equals(other: Self) {
        // Empty implementation for trait method
        return 0;
    }
}

@open
trait Display {
    fn to_string() {
        // Empty implementation for trait method
        return 0;
    }
}

@open
trait Clone {
    fn clone() {
        // Empty implementation for trait method
        return 0;
    }
}

// ---------------------------------------------------
// I/O Operations
// ---------------------------------------------------

fn write_to_file(filename: string, content: string): nil {
    var file = open(filename, "write");
    file.write(content);
    file.close();
}

fn read_from_file(filename: string): Option {
    var file = open(filename, "read");
    var content = file.read_all();
    file.close();
    return { kind: "Some", value: content };
}

// ---------------------------------------------------
// Modules
// ---------------------------------------------------

module MathUtils {
    @public
    fn add(a: int, b: int): int {
        return a + b;
    }

    @public
    fn subtract(a: int, b: int): int {
        return a - b;
    }

    fn factorial(n: int): int {
        if (n <= 1) { return 1; }
        return n * factorial(n - 1);
    }
}

import MathUtils;
print(MathUtils.add(5, 3));

// ---------------------------------------------------
// Error Handling
// ---------------------------------------------------

fn divide(a: int, b: int): Option {
    contract(b != 0, "Divisor must not be zero");
    return { kind: "Some", value: a / b };
}

match (divide(10, 0)) {
    { kind: "Some", value: result } => print("Result: {result}"),
    nil => print("Error: Division by zero")
}

// ---------------------------------------------------
// Function Contracts
// ---------------------------------------------------

fn sqrt(x: amount): amount {
    contract(x >= 0, "Cannot compute sqrt of negative number");
    var result = x ** 0.5;
    contract(result >= 0, "Result must be non-negative");
    return result;
}

// ---------------------------------------------------
// Class Contracts
// ---------------------------------------------------

class BankAccount {
    var balance: amount;

    BankAccount(initial_balance: amount) {
        contract(initial_balance >= 0, "Initial balance cannot be negative");
        self.balance = initial_balance;
    }

    fn deposit(amount: amount) {
        contract(amount > 0, "Deposit amount must be positive");
        self.balance += amount;
    }

    fn withdraw(amount: amount) {
        contract(amount > 0, "Withdrawal amount must be positive");
        contract(self.balance >= amount, "Insufficient funds");
        self.balance -= amount;
    }
}

// ---------------------------------------------------
// Loop Contracts
// ---------------------------------------------------

fn factorial(n: int): int {
    var result: int = 1;

    iter (i in 1..n) {
        contract(result > 0, "Factorial result must always be positive");
        result *= i;
    }

    return result;
}

// ---------------------------------------------------
// Compile-Time Contracts
// ---------------------------------------------------

comptime fn assert_positive(n: int) {
    contract(n > 0, "Expected positive number at compile-time");
}

comptime fn assert_valid_size(size: int) {
    contract(size > 0, "Array size must be greater than zero");
}

fn pow(base: int, exp: int): int {
    assert_positive(exp);
    var result: int = 1;
    iter (_ in 1..exp) { result *= base; }
    return result;
}

comptime fn create_lookup_table(): DictOfIntToFloat {
    var table: DictOfIntToFloat = {};
    iter (i in 1..10) {
        contract(i > 0, "Index must be positive");
        table[i] = i ** 0.5;
    }
    return table;
}

// ---------------------------------------------------
// Classes and Inheritance
// ---------------------------------------------------

@open
class Vehicle {
    var name: string;
    var speed: int;

    Vehicle(name: string, speed: int) {
        self.name = name;
        self.speed = speed;
    }

    @public
    fn display(): nil {
        print("Vehicle Name: {self.name}, Speed: {self.speed}");
    }
}

class Car(Vehicle) {
    var model: string;

    Car(name: string, speed: int, model: string): Vehicle(name, speed) {
        self.model = model;
    }

    @public
    fn display(): nil {
        print("Car Model: {self.model}, Name: {self.name}, Speed: {self.speed}");
    }
}

var my_car = Car("Toyota", 120, "Corolla");
my_car.display();

// ---------------------------------------------------
// Interfaces and Mixins
// ---------------------------------------------------

@open
interface Serializable {
    fn serialize(): string;
    fn deserialize(data: string): isTrue;
}

@open
mixin Loggable {
    fn log(message: string): nil {
        self.logger.info(message);
    }

    fn error(message: string): nil {
        self.logger.error(message);
    }
}

@open
class Base(Loggable) {
    fn init(): nil {
        self.data = "";
    }

    fn validate(): isTrue {
        return true;
    }
}

class DataHandler(Base): implements Serializable {
    var _data: string;

    @property
    fn data(): string {
        return self._data;
    }

    @public
    fn set_data(value: string): nil {
        if len(value) > 0 {
            self._data = value;
        }
    }

    @cache
    fn process_data(input: string, iterations: int = 1): string {
        var result: string = input;
        iter (i in 1..iterations) {
            result = self.transform(result);
        }
        return result;
    }

    fn serialize(): string {
        self.log("Serializing data");
        return json.stringify({
            "data": self._data,
            "timestamp": time.now()
        });
    }

    fn deserialize(data: string): isTrue {
        try {
            var parsed: ParsedResult = json.parse(data);
            self._data = parsed.data;
            return true;
        } catch {
            self.error("Failed to deserialize");
            return false;
        }
    }
}

// ---------------------------------------------------
// Parallel Processing
// ---------------------------------------------------

fn spawn_task(id: int, ch: Channel): nil {
    print("Executing parallel task {id}");
    sleep(randint(1, 3));
    ch.send("Task {id} completed");
}

var task_channel: Channel = Channel();

parallel(tasks, cores=Auto, on_error=Auto) {
    iter (var i = 1; i <= 3; i++) {
        spawn_task(i, task_channel);
    }
}

iter (message in task_channel) {
    print("Received: {message}");
}

// ---------------------------------------------------
// Concurrency
// ---------------------------------------------------

var shared_counter: Atomic = Atomic(0);
var counter_channel: Channel = Channel();

fn run_task(id: int, ch: Channel): nil {
    print("Executing concurrent task {id}");
    sleep(randint(1, 3));
    shared_counter.fetch_add(1);
    ch.send(shared_counter.get());
}

concurrent(tasks, cores=Auto, on_error=Auto) {
    iter (var i = 1; i <= 3; i++) {
        run_task(i, counter_channel);
    }
}

iter (count in counter_channel) {
    print("Updated counter: {count}");
}

// ---------------------------------------------------
// Real-Time Stream Processing
// ---------------------------------------------------

var stream_channel: Channel = Channel();

fn stream_worker(event: StreamEvent, ch: Channel): nil {
    var processed: ProcessedEvent = event.validate().normalize().enrich_with_metadata();
    ch.send(processed);
}

concurrent(stream_tasks, cores=Auto, on_error=Auto) {
    iter (event in kafka_stream.receive()) {
        stream_worker(event, stream_channel);
    }
}

iter (event in stream_channel) {
    handle_processed_event(event);
}

// ---------------------------------------------------
// Pattern Matching
// ---------------------------------------------------

fn match_example(value: any): nil {
    match(value) {
        int => print("Integer: {value}"),
        string => print("String: {value}"),
        list<int> => print("List of integers: {value}"),
        dict<string, int> => print("Dictionary: {value}"),
        _ => print("Unknown type")
    }
}

match_example(42);
match_example("Hello, Luminar!");
match_example([1, 2, 3]);
match_example({ "a": 1, "b": 2 });

// ---------------------------------------------------
// Unsafe Code
// ---------------------------------------------------

unsafe {
    var ptr = memory.allocate(1000, 8);
    memory.set(ptr, 0, 1000);
    memory.deallocate(ptr);
}

class RawBuffer {
    var ptr: *nil;
    var size: uint;

    RawBuffer(size: uint) {
        unsafe {
            self.ptr = memory.allocate(size);
            self.size = size;
        }
    }

    fn resize(new_size: uint): isTrue {
        unsafe {
            var new_ptr = memory.allocate(new_size);
            if new_ptr == nil { return false; }

            memory.copy(new_ptr, self.ptr, min(self.size, new_size));
            memory.deallocate(self.ptr);

            self.ptr = new_ptr;
            self.size = new_size;
            return true;
        }
    }

    fn ~destructor() {
        unsafe {
            memory.deallocate(self.ptr);
        }
    }
}

class SafeBuffer {
    private var raw: RawBuffer;

    SafeBuffer(size: uint) {
        contract(size > 0, "Buffer size must be positive");
        self.raw = RawBuffer(size);
    }

    fn resize(new_size: uint): Result {
        contract(new_size > 0, "New size must be positive");

        if !self.raw.resize(new_size) {
            return { kind: "Error", message: "Failed to resize buffer" };
        }

        return { kind: "Success", value: nil };
    }
}

class IntFastArray {
    private var data: *int;
    private var length: uint;
    private var capacity: uint;

    IntFastArray(initial_capacity: uint = 16) {
        unsafe {
            self.data = memory.allocate(initial_capacity * sizeof(int));
            self.length = 0;
            self.capacity = initial_capacity;
        }
    }

    fn push(item: int): nil {
        if self.length == self.capacity {
            self.grow();
        }

        unsafe {
            memory.copy(self.data + self.length, &item, sizeof(int));
            self.length += 1;
        }
    }

    private fn grow(): nil {
        unsafe {
            var new_capacity = self.capacity * 2;
            var new_data = memory.allocate(new_capacity * sizeof(int));

            memory.copy(new_data, self.data, self.length * sizeof(int));
            memory.deallocate(self.data);

            self.data = new_data;
            self.capacity = new_capacity;
        }
    }

    fn ~destructor() {
        unsafe {
            memory.deallocate(self.data);
        }
    }
}

class AtomicMemory {
    fn static exchange(ptr: *int, new_value: int): int {
        unsafe {
            return memory.atomic_exchange(ptr, new_value);
        }
    }
}

fn process_data(data: ListOfAny): Result {
    var total: int = 0;

    unsafe {
        var raw_ptr = data.as_ptr();
        var len = data.len();

        iter (var i = 0; i < len; i++) {
            total += memory.read(raw_ptr + i);
        }
    }

    return { kind: "Success", value: total };
}
