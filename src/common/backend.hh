#ifndef BACKEND_H
#define BACKEND_H

#include "../frontend/ast.hh"
#include "opcodes.hh"
#include "../backend/type_checker.hh"
#include <vector>
#include <memory>
#include <set>

class VM; // Forward declaration

// Backend interface - base class for different backend implementations
class Backend {
public:
    virtual ~Backend() = default;
    virtual void process(const std::shared_ptr<AST::Program>& program) = 0;
};

// Bytecode generation backend
class BytecodeGenerator : public Backend {
public:
    BytecodeGenerator();
    
    void process(const std::shared_ptr<AST::Program>& program) override;
    
    // Set source context for error reporting
    void setSourceContext(const std::string& source, const std::string& filePath);
    
    // Get source context
    const std::string& getSourceCode() const { return sourceCode; }
    const std::string& getFilePath() const { return filePath; }
    
    // Type checking integration
    std::vector<TypeCheckError> performTypeChecking(const std::shared_ptr<AST::Program>& program);
    
    // Get the generated bytecode
    const std::vector<Instruction>& getBytecode() const { return bytecode; }
    
    // Check if we're inside a class definition
    bool isInsideClassDefinition() const { return insideClassDefinition; }
    
private:
    std::vector<Instruction> bytecode;
    int tempVarCounter = 0;
    std::vector<size_t> loopStartAddresses;
    std::vector<size_t> loopContinueAddresses;
    std::vector<std::vector<size_t>> loopBreakPatches;
    
    // Source context for error reporting
    std::string sourceCode;
    std::string filePath;

    //MemoryManager
    std::unique_ptr<MemoryManager<>> memoryManager;
    std::unique_ptr<MemoryManager<>::Region> region;
    
    // Type checking components
    std::unique_ptr<TypeSystem> typeSystem;
    std::unique_ptr<TypeChecker> typeChecker;
    
    // Current task body being processed
    std::shared_ptr<AST::BlockStatement> current_task_body;
    
    // Track declared functions during compilation
    std::set<std::string> declaredFunctions;
    
    // Track class definition state
    bool insideClassDefinition = false;
    std::string currentClassBeingDefined;
    
    // Visitor methods for AST nodes
    void visitStatement(const std::shared_ptr<AST::Statement>& stmt);
    void visitExpression(const std::shared_ptr<AST::Expression>& expr);
    
    // Statement visitors
    void visitVarDeclaration(const std::shared_ptr<AST::VarDeclaration>& stmt);
    void visitDestructuringDeclaration(const std::shared_ptr<AST::DestructuringDeclaration>& stmt);
    void visitFunctionDeclaration(const std::shared_ptr<AST::FunctionDeclaration>& stmt);
    void visitClassDeclaration(const std::shared_ptr<AST::ClassDeclaration>& stmt);
    void visitBlockStatement(const std::shared_ptr<AST::BlockStatement>& stmt);
    void visitIfStatement(const std::shared_ptr<AST::IfStatement>& stmt);
    void visitForStatement(const std::shared_ptr<AST::ForStatement>& stmt);
    void visitWhileStatement(const std::shared_ptr<AST::WhileStatement>& stmt);
    void visitBreakStatement(const std::shared_ptr<AST::BreakStatement>& stmt);
    void visitContinueStatement(const std::shared_ptr<AST::ContinueStatement>& stmt);
    void visitReturnStatement(const std::shared_ptr<AST::ReturnStatement>& stmt);
    void visitPrintStatement(const std::shared_ptr<AST::PrintStatement>& stmt);
    void visitExprStatement(const std::shared_ptr<AST::ExprStatement>& stmt);
    void visitParallelStatement(const std::shared_ptr<AST::ParallelStatement>& stmt);
    void visitTaskStatement(const std::shared_ptr<AST::TaskStatement>& stmt);
    void visitWorkerStatement(const std::shared_ptr<AST::WorkerStatement>& stmt);
    void visitConcurrentStatement(const std::shared_ptr<AST::ConcurrentStatement>& stmt);
    void visitImportStatement(const std::shared_ptr<AST::ImportStatement>& stmt);
    void visitEnumDeclaration(const std::shared_ptr<AST::EnumDeclaration>& stmt);
    void visitMatchStatement(const std::shared_ptr<AST::MatchStatement>& stmt);
    void visitIterStatement(const std::shared_ptr<AST::IterStatement>& stmt);
    void visitModuleDeclaration(const std::shared_ptr<AST::ModuleDeclaration>& stmt);
    void visitContractStatement(const std::shared_ptr<AST::ContractStatement>& stmt);
    
    // Expression visitors
    void visitBinaryExpr(const std::shared_ptr<AST::BinaryExpr>& expr);
    void visitUnaryExpr(const std::shared_ptr<AST::UnaryExpr>& expr);
    void visitLiteralExpr(const std::shared_ptr<AST::LiteralExpr>& expr);
    void visitVariableExpr(const std::shared_ptr<AST::VariableExpr>& expr);
    void visitCallExpr(const std::shared_ptr<AST::CallExpr>& expr);
    void visitAssignExpr(const std::shared_ptr<AST::AssignExpr>& expr);
    void visitGroupingExpr(const std::shared_ptr<AST::GroupingExpr>& expr);
    void visitListExpr(const std::shared_ptr<AST::ListExpr>& expr);
    void visitTupleExpr(const std::shared_ptr<AST::TupleExpr>& expr);
    void visitDictExpr(const std::shared_ptr<AST::DictExpr>& expr);
    void visitIndexExpr(const std::shared_ptr<AST::IndexExpr>& expr);
    void visitMemberExpr(const std::shared_ptr<AST::MemberExpr>& expr);
    void visitAwaitExpr(const std::shared_ptr<AST::AwaitExpr>& expr);
    void visitRangeExpr(const std::shared_ptr<AST::RangeExpr>& expr);
    void visitInterpolatedStringExpr(const std::shared_ptr<AST::InterpolatedStringExpr>& expr);
    
    // Error handling expression visitors
    void visitFallibleExpr(const std::shared_ptr<AST::FallibleExpr>& expr);
    void visitErrorConstructExpr(const std::shared_ptr<AST::ErrorConstructExpr>& expr);
    void visitOkConstructExpr(const std::shared_ptr<AST::OkConstructExpr>& expr);
    
    // Pattern expression visitors for match statements
    void visitTypePatternExpr(const std::shared_ptr<AST::TypePatternExpr>& expr);
    void visitBindingPatternExpr(const std::shared_ptr<AST::BindingPatternExpr>& expr);
    void visitDictPatternExpr(const std::shared_ptr<AST::DictPatternExpr>& expr);
    void visitTuplePatternExpr(const std::shared_ptr<AST::TuplePatternExpr>& expr);
    void visitListPatternExpr(const std::shared_ptr<AST::ListPatternExpr>& expr);
    
    // Error pattern expression visitors
    void visitValPatternExpr(const std::shared_ptr<AST::ValPatternExpr>& expr);
    void visitErrPatternExpr(const std::shared_ptr<AST::ErrPatternExpr>& expr);
    void visitErrorTypePatternExpr(const std::shared_ptr<AST::ErrorTypePatternExpr>& expr);
    
    // Lambda expression visitor
    void visitLambdaExpr(const std::shared_ptr<AST::LambdaExpr>& expr);
    
    // Helper methods
    void emit(Opcode op, uint32_t lineNumber, 
              int64_t intValue = 0, 
              float floatValue = 0.0f, 
              bool boolValue = false, 
              const std::string& stringValue = "");
    void emit(Opcode op, uint32_t lineNumber, uint64_t uint64Value);
    
    // Variable capture analysis for closures
    std::vector<std::string> analyzeVariableCapture(const std::shared_ptr<AST::LambdaExpr>& lambda);
    void findCapturedVariables(const std::shared_ptr<AST::Expression>& expr, 
                              const std::vector<std::string>& localVars,
                              std::set<std::string>& capturedVars);
    void findCapturedVariables(const std::shared_ptr<AST::Statement>& stmt,
                              const std::vector<std::string>& localVars,
                              std::set<std::string>& capturedVars);
    
    // Module resolution helpers
    std::string resolveModulePath(const std::string& modulePath);
    std::string getModuleNameFromPath(const std::string& modulePath);
    
    // Function declaration tracking
    bool isDeclaredFunction(const std::string& name) const;
    void addDeclaredFunction(const std::string& name);
};

#endif // BACKEND_H