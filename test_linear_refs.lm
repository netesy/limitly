// Test file for linear types with reference semantics
// Each variable is a linear type, assignments create references

fn test_linear_type_references() {
    var data = [1, 2, 3, 4, 5]  // Linear type owns data
    
    // Create references - these are FREE, no ownership transfer
    var ref1 = data  // Reference to linear type
    var ref2 = data  // Another reference to same linear type
    var ref3 = data  // Multiple references allowed
    
    // All references and original can access data
    print("data = {data}")
    print("ref1 = {ref1}")
    print("ref2 = {ref2}")
    print("ref3 = {ref3}")
    
    // Move the linear type - all references become invalid
    var new_owner = data  // Move linear type to new owner
    
    // This should fail - data is moved
    // print("moved data = {data}")  // ERROR: Use of moved linear type
    
    // This should fail - references invalidated by move
    // print("invalid ref1 = {ref1}")  // ERROR: Use of invalid reference
    // print("invalid ref2 = {ref2}")  // ERROR: Use of invalid reference
    // print("invalid ref3 = {ref3}")  // ERROR: Use of invalid reference
    
    // Only new_owner is valid
    print("new_owner = {new_owner}")
}

fn test_reference_chaining() {
    var source = "hello world"  // Linear type
    
    var ref_a = source  // Reference to source
    var ref_b = ref_a   // Reference to reference (should resolve to source)
    
    print("source = {source}")
    print("ref_a = {ref_a}")
    print("ref_b = {ref_b}")
    
    // Move source - both references invalidated
    var moved = source
    
    // Only moved is valid now
    print("moved = {moved}")
}

fn test_multiple_linear_types() {
    var first = [1, 2, 3]
    var second = [4, 5, 6]
    
    var ref_first = first
    var ref_second = second
    
    // Both linear types and references valid
    print("first = {first}, second = {second}")
    print("ref_first = {ref_first}, ref_second = {ref_second}")
    
    // Move first - only first references invalidated
    var moved_first = first
    
    // second and its references still valid
    print("second = {second}")
    print("ref_second = {ref_second}")
    print("moved_first = {moved_first}")
}

fn main() {
    print("=== Linear Type Reference Tests ===")
    test_linear_type_references()
    test_reference_chaining()
    test_multiple_linear_types()
    print("=== All Tests Complete ===")
}
