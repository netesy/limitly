// Test file for enhanced reference system with mutable aliasing and lifetime analysis

fn test_mutable_aliasing() {
    var datas = [1, 2, 3]
    
    // Immutable references - multiple allowed
    var ref1 = datas
    var ref2 = datas
    var ref3 = datas
    
    print("immutable refs: ref1={ref1}, ref2={ref2}, ref3={ref3}")
    
    // Mutable reference - should be exclusive
    // var mutable_ref = datas // ERROR: Other references exist
    
    // Clear immutable refs first
    ref1 = nil
    ref2 = nil
    ref3 = nil
    
    // Now mutable reference allowed
    var mutable_ref = datas
    print("mutable_ref = {mutable_ref}")
    
    // Cannot create other refs while mutable exists
    // var another_ref = datas // ERROR: Mutable reference exists
}

fn test_lifetime_escape() {
    var local_datas= "hello world"
    
    {
        var inner_ref = local_datas // Created in inner scope
        print("inner_ref = {inner_ref}")
        
        // This would escape - should be error
        // return inner_ref  // ERROR: Reference escaping scope
    }
    
    print("local_datas= {local_datas}")
}

fn test_mutable_lifetime() {
    var datas = [10, 20, 30]
    
    {
        var mutable_ref = datas // Mutable ref in inner scope
        mutable_ref[0] = 99  // Modify through mutable ref
        print("modified in inner scope: {mutable_ref}")
        
        // Cannot escape mutable reference
        // return mutable_ref  // ERROR: Mutable reference escaping
    }
    
    print("original data: {datas}")
}

fn test_scope_tracking() {
    var outer = "outer data"
    
    var outer_ref = outer  // Valid - same scope
    
    if(true){
        var inner = "inner data";
        var inner_ref = inner;  // Valid - same scope
        
        // Cannot use inner_ref outside this block
        // outer_ref = inner_ref  // ERROR if inner_ref escapes
    }
    
    print("outer_ref = {outer_ref}")
}

fn test_generation_with_mutability() {
    var datas= [1, 2, 3]
    
    var immutable_ref = datas // Immutable reference
    print("before move: ref={immutable_ref}")
    
    var moved = datas // Move - all refs invalidated
    print("moved = {moved}")
    
    // immutable_ref now invalid
    // print("after move: ref={immutable_ref}")  // ERROR: Stale reference
    
    // Can create new references to moved data
    var new_ref = moved
    print("new_ref = {new_ref}")
}

fn main() {
    print("=== Enhanced Reference Tests ===")
    test_mutable_aliasing()
    test_lifetime_escape()
    test_mutable_lifetime()
    test_scope_tracking()
    test_generation_with_mutability()
    print("=== All Tests Complete ===")
}
