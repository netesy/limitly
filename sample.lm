// sample.lm

// Luminar Programming Language
// Key Features:
// - Controlled Unsafe Operations

// ---------------------------------------------------
// Basic Syntax
// ---------------------------------------------------

// ---------------------------------------------------
// Core Type System
// ---------------------------------------------------

// Primitive Types
type date = i64;          // Default integer type
type numbers = u64;         // Unsigned integer
type amount = f64;        // Default float type
type isTrue = bool;     // Boolean type
type string = str;       // String type

// Type Aliases
type Id = uint;
type Name = str;
type Age = uint;

// Generic Type Parameters
type Result<T, E> = Success(T) | Error(E);
type Option<T> = Some(T) | nil;
type List<T> = [T];
type Dict<K: Hashable, V> = {K: V};

// Union Types
type NumberType = int | float;
type StringOrNumber = str | NumberType;

// Refined Types
type PositiveInt = int where value > 0;
type EmailString = str where matches(value, "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$");
type Percentage = float where value >= 0.0 and value <= 100.0;

// Structural Types (Row Polymorphism)
type HasName = { name: str, ...};
type HasAge = { age: uint, ...};
type Person = HasName and HasAge;

// Traits (Interfaces)
//!todo Not Yet Implemented
@open
trait Hashable {
    fn hash(): uint;
    fn equals(other: Self): bool;
}

@open
trait Display {
    fn to_string(): str;
}

@open
trait Clone {
    fn clone(): Self;
}

// Arithmetic and Logical Operations
print(10 + 5 * 2);                  // Output: 20
print((10 > 5) and (5 < 2));        // false
print("Hello, " + "Luminar!");      // String concatenation

// ---------------------------------------------------
// Loops
// ---------------------------------------------------
// C style for loops for legacy code
for (var i = 0; i < 10; i += 1) {
    print(i);
}

// Range-based loop
iter (i in 1..5) {
  print("Range iteration: {i}");
}

// List-based loop
var fruits: list<str> = ["Apple", "Banana", "Cherry"];
iter (fruit in fruits) {
  print(fruit);
}

// List-based loop
var fruits: list = ["Apple", "Banana", "Cherry"];
iter (fruit in fruits) {
  print(fruit);
}

// Dictionary iteration
var my_dict: dict = {"a": 1, "b": 2, "c": 3};
iter (key, value in my_dict) {
    print("{key}: {value}");
}

var my_dict: dict<str, int> = {"a": 1, "b": 2, "c": 3};
iter (key, value in my_dict) {
    print("{key}: {value}");
}

// Nested loop
iter (x in 1..3) {
  iter (y in 1..2) {
    print("x: {x}, y: {y}");
  }
}

// While loop
var count: int = 0;
while (count < 3) {
  print("Count: {count}");
  count += 1;
}

// ---------------------------------------------------
// I/O Operations
// ---------------------------------------------------

// Experimental: File handling
fn write_to_file(filename: str, content: str): nil {
  var file = open(filename, "write");
  file.write(content);
  file.close();
}

fn read_from_file(filename: str): str? {
  var file = open(filename, "read");
  var content = file.read_all();
  file.close();
  return content;
}

// Usage example:
// write_to_file("example.txt", "Hello, File!");
// var content = read_from_file("example.txt");
// print(content.unwrap_or("File could not be read"));

// ---------------------------------------------------
// Modules
// ---------------------------------------------------
@private: Accessible only within the file.
@protected: Accessible within the module but not externally.

module MathUtils {
    @public
    fn add(a: int, b: int): int {
        return a + b;
    }

    @public
    fn subtract(a: int, b: int): int {
        return a - b;
    }

    fn factorial(n: int): int {
        if n <= 1 { return 1; }
        return n * factorial(n - 1);
    }
}

import MathUtils;
print(MathUtils.add(5, 3));         // Output: 8
print(MathUtils.factorial(4));      // Should Output: 24 but the module method is not public

// ---------------------------------------------------
// Error Handling
// ---------------------------------------------------

fn divide(a: int, b: int): int? {
  contract(b != 0, "Divisor must not be zero");
  return a / b;
}

match divide(10, 0) {
  Some(result) => print("Result: {result}"),
  None => print("Error: Division by zero")
}

// ────────────────────────────────────────────────────────────────────
// Function Contracts: Preconditions & Postconditions
// ────────────────────────────────────────────────────────────────────

fn sqrt(x: float): float {
    contract(x >= 0, "Cannot compute sqrt of negative number"); // Precondition

    var result = x ** 0.5;

    contract(result >= 0, "Result must be non-negative"); // Postcondition
    return result;
}

// ────────────────────────────────────────────────────────────────────
// Class Contracts: Ensuring Invariants
// ────────────────────────────────────────────────────────────────────

class BankAccount {
    var balance: float;

    // Constructor enforces initial invariants
    BankAccount(initial_balance: float) {
        contract(initial_balance >= 0, "Initial balance cannot be negative");
        self.balance = initial_balance;
    }

    // Method contracts enforce valid operations
    fn deposit(amount: float) {
        contract(amount > 0, "Deposit amount must be positive");
        self.balance += amount;
    }

    fn withdraw(amount: float) {
        contract(amount > 0, "Withdrawal amount must be positive");
        contract(self.balance >= amount, "Insufficient funds");
        self.balance -= amount;
    }
}

