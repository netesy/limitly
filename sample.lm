// sample.lm

// Luminar Programming Language
// Key Features:
// - Controlled Unsafe Operations

// ---------------------------------------------------
// Basic Syntax
// ---------------------------------------------------

// ---------------------------------------------------
// Core Type System
// ---------------------------------------------------

// === Primitive Types ===
type date = i64;
type numbers = u64;
type amount = f64;
type isTrue = bool;
type string = str;

// === Type Aliases ===
type Id = uint;
type Name = str;
type Age = uint;

// === Option Type ===
//type Some = { kind: "Some", value: any };
//type None = nil;  

//type Option = Some | None;
type options = { kind: "Some", value: any } | nil;

// Example usage:
// var maybeName: Option = { kind: "Some", value: "Alice" };
// var noValue: Option = nil;

// === Result Type ===
type Success = { kind: "Success", value: any };
type Error = { kind: "Error", message: any };

type Result = Success | Error;

// Example usage:
// var res: Result = { kind: "Success", value: 42 };
// var err: Result = { kind: "Error", message: "Not found" };

// === Collection Types ===
type ListOfAny = [any];
type ListOfString = [str];
type ListOfPerson = [Person];

type DictOfAny = {any: any};
type DictOfString = {str: str};
type DictOfIntToUser = {int: User};

// === Union Types ===
type NumberType = int | f64;
type StringOrNumber = str | NumberType;

// === Refined Types ===
type PositiveInt = int where value > 0;
type EmailString = str where matches(value, "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$");
type Percentage = float where value >= 0.0 and value <= 100.0;

// === Structural Types ===
type HasName = { name: str };
type HasAge = { age: uint };
type Person = HasName and HasAge;

// === Extensible Structural Types ===
type Address = { street: str, city: str, zipcode: str };
type ContactInfo = { email: str, phone: str };
type Employee = { ...Person, ...Address, ...ContactInfo, employeeId: uint, department: str };
type Manager = { ...Employee, managedTeam: [Employee] };
type ExtendedRecord = { ...BaseRecord, newField: int };
type MultipleBaseRecord = { ...Base1, ...Base2, additionalField: bool };

// Arithmetic and Logical Operations
print(10 + 5 * 2);                  // Output: 20
print((10 > 5) and (5 < 2));        // false
print("Hello, " + "Luminar!");      // String concatenation

// === Arithmetic and Logical Operations ===
print(10 + 5 * 2);                  // Output: 20
print((10 > 5) and (5 < 2));        // false
print("Hello, " + "Luminar!");      // String concatenation

// === Loops ===

// C-style loop
for (var i = 0; i < 10; i += 1) {
    print(i);
}

// Range-based loop
iter (i in 1..5) {
    print("Range iteration: {i}");
}

// List-based loop with explicit string list type
var fruits: ListOfString = ["Apple", "Banana", "Cherry"];
iter (fruit in fruits) {
    print(fruit);
}

// Dictionary-based loop with defined key/value type
type DictOfStrToInt = { string: int };
var my_dict: DictOfStrToInt = { "a": 1, "b": 2, "c": 3 };
iter (key, value in my_dict) {
    print("{key}: {value}");
}

// Nested loop
iter (x in 1..3) {
    iter (y in 1..2) {
        print("x: {x}, y: {y}");
    }
}

// While loop
var count: int = 0;
while (count < 3) {
    print("Count: {count}");
    count += 1;
}

// === Traits (Interfaces) ===

@open
trait Hashable {
    fn hash(): uint;
    fn equals(other: Self): isTrue;
}

@open
trait Display {
    fn to_string(): string;
}

@open
trait Clone {
    fn clone(): Self;
}

// === I/O Operations ===

/// Writes string content to a file.
fn write_to_file(filename: string, content: string): None {
    var file = open(filename, "write");
    file.write(content);
    file.close();
}

/// Reads full contents of a file. Returns `Option`.
fn read_from_file(filename: string): Option {
    var file = open(filename, "read");
    var content = file.read_all();
    file.close();
    return { kind: "Some", value: content };
}

// === Modules ===

@private: Accessible only within the file.
@protected: Accessible within the module but not externally.

module MathUtils {
    @public
    fn add(a: int, b: int): int {
        return a + b;
    }

    @public
    fn subtract(a: int, b: int): int {
        return a - b;
    }

    fn factorial(n: int): int {
        if (n <= 1) { return 1; }
        return n * factorial(n - 1);
    }
}

import MathUtils;
print(MathUtils.add(5, 3));         // Output: 8
// print(MathUtils.factorial(4));   // Not public, won't compile

// === Error Handling ===

/// Division that guards against zero using a contract. Returns `Option`.
fn divide(a: int, b: int): Option {
    contract(b != 0, "Divisor must not be zero");
    return { kind: "Some", value: a / b };
}

match (divide(10, 0)) {
    { kind: "Some", value: result } => print("Result: {result}"),
    nil => print("Error: Division by zero")
}

// === Function Contracts ===

/// Square root function with pre- and post-conditions.
fn sqrt(x: amount): amount {
    contract(x >= 0, "Cannot compute sqrt of negative number");
    var result = x ** 0.5;
    contract(result >= 0, "Result must be non-negative");
    return result;
}

// === Class Contracts ===

/// A simple bank account class enforcing invariant rules.
class BankAccount {
    var balance: amount;

    BankAccount(initial_balance: amount) {
        contract(initial_balance >= 0, "Initial balance cannot be negative");
        self.balance = initial_balance;
    }

    fn deposit(amount: amount) {
        contract(amount > 0, "Deposit amount must be positive");
        self.balance += amount;
    }

    fn withdraw(amount: amount) {
        contract(amount > 0, "Withdrawal amount must be positive");
        contract(self.balance >= amount, "Insufficient funds");
        self.balance -= amount;
    }
}
