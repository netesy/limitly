#!/usr/bin/env python3
"""
Simple goembed-like generator for Limit bytecode text files.

Usage:
  tools\goembed.py input.bytecode.txt embed_name output_prefix

Generates:
  src\lembed_generated.hh
  src\lembed_generated.cpp

The generated registration function is `registerGeneratedEmbeds()`.
"""
import sys
import os
import re

def parse_bytecode_lines(lines):
    # Very small parser: convert each textual opcode line into a C++ initializer
    instrs = []
    opcode_pattern = re.compile(r"\d+\s*:\s*(\w+)\s*(?:\(line\s*\d+\))?\s*(.*)")
    for line in lines:
        line = line.strip()
        if not line or line.startswith("//") or line.startswith("Bytecode"):
            continue
        m = opcode_pattern.match(line)
        if not m:
            continue
        opname = m.group(1)
        operand = m.group(2).strip()
        # Normalize operand
        if operand == "":
            instrs.append((opname, None))
        else:
            instrs.append((opname, operand))
    return instrs

def emit_cpp(name, instrs, out_cpp, out_hh):
    with open(out_hh, 'w', encoding='utf-8') as fh:
        fh.write('#ifndef LEMBED_GENERATED_HH\n')
        fh.write('#define LEMBED_GENERATED_HH\n\n')
        fh.write('extern "C" void registerGeneratedEmbeds();\n\n')
        fh.write('#endif\n')

    with open(out_cpp, 'w', encoding='utf-8') as fh:
        fh.write('#include "lembed.hh"\n')
        fh.write('#include "opcodes.hh"\n')
        fh.write('#include <string>\n')
        fh.write('#include <vector>\n\n')
        fh.write('// Generated by tools/goembed.py\n')
        fh.write('static Instruction I(Opcode op, uint32_t line = 0, int64_t iv = 0, float fv = 0.0f, bool bv = false, const std::string& sv = "") {\n')
        fh.write('    Instruction ins; ins.opcode = op; ins.line = line; ins.intValue = iv; ins.floatValue = fv; ins.boolValue = bv; ins.stringValue = sv; return ins;\n')
        fh.write('}\n\n')
        fh.write('extern "C" void registerGeneratedEmbeds() {\n')
        fh.write('    // Embed: %s\n' % name)
        fh.write('    lembed::Bytecode bc;\n')
        for opname, operand in instrs:
            # Basic mapping: if operand is quoted string, keep as stringValue
            if operand is None:
                fh.write('    bc.push_back(I(Opcode::%s));\n' % opname)
            else:
                # Try to see if operand is an int
                op = operand.split()[0]
                if re.match(r"^-?\d+$", op):
                    fh.write('    bc.push_back(I(Opcode::%s, 0, %s));\n' % (opname, op))
                elif op.startswith('"') and op.endswith('"'):
                    s = op.strip('"').replace('\\', '\\\\').replace('"', '\\"')
                    fh.write('    bc.push_back(I(Opcode::%s, 0, 0, 0.0f, false, "%s"));\n' % (opname, s))
                else:
                    # fallback: treat entire operand as string
                    s = operand.replace('\\', '\\\\').replace('"', '\\"')
                    fh.write('    bc.push_back(I(Opcode::%s, 0, 0, 0.0f, false, "%s"));\n' % (opname, s))
        fh.write('    bc.push_back(I(Opcode::HALT, 0));\n')
        fh.write('    lembed::registerEmbed("%s", bc);\n' % name)
        fh.write('}\n')

def main():
    if len(sys.argv) < 4:
        print('Usage: goembed.py input.bytecode.txt embed_name output_prefix')
        return 1
    infile = sys.argv[1]
    embed_name = sys.argv[2]
    out_prefix = sys.argv[3]
    with open(infile, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    instrs = parse_bytecode_lines(lines)
    emit_cpp(embed_name, instrs, out_prefix + '.cpp', out_prefix + '.hh')
    print('Generated', out_prefix + '.cpp', 'and', out_prefix + '.hh')
    return 0

if __name__ == '__main__':
    sys.exit(main())
