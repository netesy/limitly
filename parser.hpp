// parser.h
#ifndef PARSER_H
#define PARSER_H

#include "opcodes.hpp"
#include "scanner.hpp"
#include "syntax.hpp"

class Parser
{
public:
    Parser(Scanner &scanner)
        : scanner(scanner)
    {}

    void parse();

private:
    Scanner &scanner;  // Reference to the scanner
    Syntax syntax;     // Instance of Syntax for syntax parsing
    std::vector<Instruction> bytecode; // Vector to hold generated bytecode instructions

    void parseStatement();
    void parseExpression(int precedence = 0);
    void parsePrimary();
    void parseUnary();
    void parseBinary(int precedence);
    void parseTernary();
    void parseLogicalOr();
    void parseLogicalAnd();
    void parseEquality();
    void parseComparison();
    void parseAddition();
    void parseSubstraction();
    void parseMultiplication();
    void parseDivision();
    void parseModulus();
    void parseFunctionDeclaration();
    void parseForLoop();
    void parseWhileLoop();
    void parseConditional();
    void parseClassDeclaration();
    void parseVariableDeclaration();
    void parseAssignment();
    void parseAttempt();
    void parseString();
    void parseConcurrent();
    void parseParallel();
    void parseAwait();
    void parseAsync();
    void parseIdentifier();
    void parseType();
    void parseArguments();
    void parsePatternMatching();
    void parseMatchCase();

    //helper
    void error(const std::string &message, int line = 0, int start = 0);
    void emit(Opcode op,
              uint32_t lineNumber,
              int32_t intValue = 0,
              float floatValue = 0.0f,
              bool boolValue = false,
              const std::string &stringValue = "");
    void consume(TokenType expectedType);
    bool isUnaryOperator(TokenType type);
    int getPrecedence(TokenType type);
};

#endif // PARSER_H
