print("=== Concurrent Block Tests ===");

// ==========================================
//  Basic concurrent execution (batch mode)
// ==========================================
// concurrent = I/O-bound, default mode=batch
var shared_counter: atomic = 0;  // atomic for primitives, locked for objects

counts = channel();
concurrent(ch=counts, mode=batch, cores=Auto, on_error=Stop,
           timeout=20s, grace=500ms, on_timeout=partial) {
    task(i in 1..3) {
        print("Concurrent task {i} running");
        sleep(randint(1, 3));
        shared_counter += 1;  // atomic add
        counts.send(shared_counter);
    }
} // auto-close counts when done or timeout+grace reached

iter (count in counts) {
    print("Updated counter: {count}");
}
print("Concurrent block finished");


// Test parallel blocks 
print("=== Parallel Block Tests ===");

// ==========================================
//  Batch parallel block (CPU bound)
// ==========================================
messages = channel();
parallel(ch=messages, mode=batch, cores=Auto, on_error=Auto,
         timeout=20s, grace=500ms, on_timeout=partial) {
    task(i in 1..3) {
        print("Task {i} running");
        sleep(randint(1, 3));
        messages.send("Task {i} done");
    }
} // auto-close messages

iter (message in messages) {
    print("Received: {message}");
}

// ==========================================
//  Stream processing (CPU bound, retries)
// ==========================================
files_out = channel();
parallel(events: FileChunks, ch=files_out, mode=stream, cores=Auto,
         on_error=Retry, timeout=60s,
         grace=500ms, on_timeout=partial) {
    worker(chunk) {
        process_chunk(chunk);
        files_out.send("Chunk {chunk.id} processed");
    }
} // auto-close files_out

iter (msg in files_out) {
    print(msg);
}

// ==========================================
//  Concurrent block with no parameters
// ==========================================
concurrent {
    task(i in 1..2) {
        print("Task {i} with default parameters");
    }
}

// ==========================================
//  Parallel block with invalid parameter
// ==========================================
// This should be handled gracefully by the parser
parallel(invalid_param="test") {
    task(i in 1..2) {
        print("This should not be executed");
    }
}


// Test parallel blocks 
print("=== Parallel Block Tests ===");

// ==========================================
//  Batch parallel block (CPU bound)
// ==========================================
var messages = channel();
parallel(ch=messages, mode=batch, cores=Auto, on_error=Auto,
         timeout=20s, grace=500ms, on_timeout=partial) {
    
    // Task statement for parallel execution
    task(i in 1..3) {
        print("Task {i} running");
        sleep(randint(1, 3)); // these are assumed to be system functions
        messages.send("Task {i} done");
    }
} // auto-close messages

// Process messages from parallel tasks
iter (message in messages) {
    print("Received: {message}");
}

// ==========================================
//  Stream processing (CPU bound, retries)
// ==========================================
var files_out = channel();
parallel(events: FileChunks, ch=files_out, mode=stream, cores=Auto,
         on_error=Retry, timeout=60s,
         grace=500ms, on_timeout=partial) {
    
    // Worker definition for processing chunks
    worker(chunk) {
        // Process the chunk and send result
        process_chunk(chunk);
        files_out.send("Chunk {chunk.id} processed");
    }
} // auto-close files_out

// Process output from workers
iter (msg in files_out) {
    print(msg);
}