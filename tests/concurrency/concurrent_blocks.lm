// Test concurrent blocks (if implemented)
print("=== Concurrent Block Tests ===");

// Basic concurrent block
print("Basic concurrent execution:");
cvar shared_counter: Atomic = Atomic(0);
var counter_channel: Channel = Channel();

fn run_task(id: int, ch: Channel): nil {
    print("Executing concurrent task {id}");
    sleep(randint(1, 3));
    shared_counter.fetch_add(1);
    ch.send(shared_counter.get());
}

concurrent(tasks, cores=Auto, on_error=Auto) {
    iter (var i = 1; i <= 3; i++) {
        run_task(i, counter_channel);
    }
}

iter (count in counter_channel) {
    print("Updated counter: {count}");
}

print("Concurrent block finished");

// Async/await pattern
print("Async/await test:");
async function fetchData(id) {
    print("Fetching data for ID: {id}");
    // Simulate async work
    return "Data for {id}";
}

async function processData() {
    var data1 = await fetchData(1);
    var data2 = await fetchData(2);
    print("Processed: {data1}, {data2}");
}

processData();

// Concurrent with shared resources
var stream_channel: Channel = Channel();

fn stream_worker(event: StreamEvent, ch: Channel): nil {
    var processed: ProcessedEvent = event.validate().normalize().enrich_with_metadata();
    ch.send(processed);
}

concurrent(stream_tasks, cores=Auto, on_error=Auto) {
    iter (event in kafka_stream.receive()) {
        stream_worker(event, stream_channel);
    }
}

iter (event in stream_channel) {
    handle_processed_event(event);
}

print("Final counter value: {counter}");