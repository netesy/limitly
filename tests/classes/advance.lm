// ===========================================
// COMPREHENSIVE CLASS INHERITANCE & CONSTRUCTOR EXAMPLES
// ===========================================

print("=== Class Inheritance Tests ===")

// ===========================================
// INLINE CONSTRUCTOR APPROACH (Simple Classes)
// ===========================================

// Base class with constructor shorthand
class Animal(name: str) {
    fn speak() {
        print("{self.name} makes a sound");
    }
    
    fn info() {
        print("Animal is {self.name}");
    }
}

// Derived class with super constructor call
class Dog(name: str, breed: str) : Animal(name) {
    fn speak() {
        print("{self.name} barks!");
    }
    
    fn wagTail() {
        print("{self.name} wags tail happily");
    }
    
    fn info() {
        print("Dog {self.name} is a {self.breed}");
    }
}

// Another derived class
class Cat(name: str) : Animal(name) {
    fn speak() {
        print("{self.name} meows");
    }
    
    fn purr() {
        print("{self.name} purrs contentedly");
    }
}

// Alternative syntax for more complex inheritance scenarios
class SmartDog(name: str, breed: str, iq: int) : Dog(name, breed) {
    fn speak() {
        super.speak();  // Call parent method
        print("Woof woof! (intelligently)");
    }
    
    fn solve(problem: str) {
        print("{self.name} solves: {problem}");
    }
}

// Simple classes with inline constructors
class Point(x: float, y: float) {
    fn distance() {
        return sqrt(self.x * self.x + self.y * self.y);
    }
    
    fn toString() {
        return "Point({self.x}, {self.y})";
    }
}

// ===========================================
// EXPLICIT CONSTRUCTOR APPROACH (Complex Classes)
// ===========================================

// Complex database connection class with explicit constructor
class DatabaseConnection {
    var host: str;
    var port: int;
    var isConnected: bool;
    var connectionId: str;
    
    fn init(host: str, port: int = 5432) {
        self.host = host;
        self.port = port;
        self.isConnected = false;
        self.connectionId = self.generateId();
        self.connect();
    }
    
    fn connect() {
        // Complex connection logic
        print("Connecting to {self.host}:{self.port}");
        self.isConnected = true;
        print("Connection established with ID: {self.connectionId}");
    }
    
    fn generateId() {
        return "conn_" + str(rand(1000, 9999));
    }
    
    fn disconnect() {
        self.isConnected = false;
        print("Disconnected from {self.host}");
    }
}

// Complex user class with validation in constructor
class ValidatedUser {
    var email: str;
    var age: int;
    var isVerified: bool;
    
    fn init(email: str, age: int) {
        if (!self.isValidEmail(email)) {
            print("Invalid email format");
        }
        if (age < 0 || age > 150) {
            print("Invalid age range");
        }
        
        self.email = email;
        self.age = age;
        self.isVerified = false;
        
        print("User created: {self.email}");
    }
    
    fn isValidEmail(email: str) {
        return true; //email.contains("@") && email.contains(".");
    }
    
    fn verify() {
        self.isVerified = true;
        print("User {self.email} has been verified");
    }
}

// Complex inheritance with explicit constructors
class AdminUser extends ValidatedUser {
    var permissions: [str];
    var accessLevel: int;
    
    fn init(email: str, age: int, accessLevel: int) {
        super.init(email, age);
        self.accessLevel = accessLevel;
        self.permissions = self.getDefaultPermissions();
        print("Admin user created with access level {self.accessLevel}");
    }
    
    fn getDefaultPermissions() {
        if (self.accessLevel >= 10) {
            return ["read", "write", "delete", "admin"];
        } else {
            return ["read", "write"];
        }
    }
    
    fn addPermission(perm: str) {
        if (!self.permissions.contains(perm)) {
            self.permissions.append(perm);
            print("Added permission: {perm}");
        }
    }
}

// ===========================================
// VIRTUAL/ABSTRACT CLASS EXAMPLE
// ===========================================

// Virtual class example (abstract-like behavior)
class Shape {
    fn area() {
        //use panic when done
        print("Must override area()");
    }
    
    fn perimeter() {
        print("Must override perimeter()");
    }
    
    fn describe() {
        print("Shape with area {self.area()} and perimeter {self.perimeter()}");
    }
}

class Circle(radius: float) : Shape {
    fn area() {
        return 3.14159 * self.radius * self.radius;
    }
    
    fn perimeter() {
        return 2 * 3.14159 * self.radius;
    }
}

class Rectangle(width: float, height: float) : Shape {
    fn area() {
        return self.width * self.height;
    }
    
    fn perimeter() {
        return 2 * (self.width + self.height);
    }
}

// ===========================================
// TESTING ALL APPROACHES
// ===========================================

print("=== Inline Constructor Examples ===")

// Test simple inheritance
var dog = Dog("Buddy", "Golden Retriever");
var cat = Cat("Whiskers");
var smartDog = SmartDog("Einstein", "Border Collie", 150);
var point = Point(3.0, 4.0);

print("Dog methods:")
dog.info();
dog.speak();
dog.wagTail();

print("\nCat methods:")
cat.info();
cat.speak();
cat.purr();

print("\nSmart dog methods:")
smartDog.info();
smartDog.speak();
smartDog.solve("fetch puzzle");

print("\nPoint methods:")
print(point.toString());
print("Distance from origin: {point.distance()}");

// ===========================================

print("\n=== Explicit Constructor Examples ===")

// Test complex classes with explicit constructors
var conn = DatabaseConnection("localhost", 5432);
conn.disconnect();

print("\nValidated user creation:")
var user = ValidatedUser("test@example.com", 25);
user.verify();

print("\nAdmin user creation:")
var admin = AdminUser("admin@example.com", 30, 15);
admin.addPermission("super_admin");

// ===========================================

print("\n=== Polymorphism Tests ===")

// Test polymorphism with inline constructor classes
print("Animal polymorphism:")
var animals = [dog, cat, smartDog];
for animal in animals {
    animal.speak();
}

// Test polymorphism with abstract-like classes
print("\nShape polymorphism:")
var shapes = [Circle(5.0), Rectangle(4.0, 6.0)];
for shape in shapes {
    shape.describe();
}

// ===========================================

print("\n=== Mixed Usage Demonstration ===")

// Demonstrate when to use each approach
print("Use inline constructors for:")
print("- Simple data classes")
print("- Classes with minimal initialization logic")
print("- Quick prototyping")

var simplePoint = Point(1.0, 1.0);
var simpleDog = Dog("Rex", "Labrador");

print("\nUse explicit constructors for:")
print("- Complex initialization logic")
print("- Validation requirements")
print("- Multi-step setup processes")

var complexUser = ValidatedUser("complex@example.com", 35);
var dbConn = DatabaseConnection("production.db", 3306);

print("\n=== Summary ===")
print("Both approaches coexist:")
print("- Inline: class Name(param: type)")
print("- Explicit: class Name { fn init(param: type) { ... } }")
print("Choose based on complexity and requirements!")