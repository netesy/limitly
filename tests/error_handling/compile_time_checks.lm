// Test file for compile-time error type checking

// Test 1: Function with error union return type
fn divide(a: int, b: int): int?DivisionByZero {
    if (b == 0) {
        return err(DivisionByZero);
    }
    return ok(a / b);
}

// Test 2: Function that propagates errors correctly
fn safeDivide(x: int, y: int): int?DivisionByZero {
    var result = divide(x, y)?;  // Should work - compatible error types
    return ok(result);
}

// Test 3: Function that tries to propagate incompatible error types (should fail)
fn incompatiblePropagate(x: int, y: int): int?IndexOutOfBounds {
    var result = divide(x, y)?;  // Should fail - DivisionByZero not compatible with IndexOutOfBounds
    return ok(result);
}

// Test 4: Non-fallible function trying to use ? operator (should fail)
fn nonFallibleWithPropagation(x: int, y: int): int {
    var result = divide(x, y)?;  // Should fail - cannot propagate in non-fallible function
    return result;
}

// Test 5: Unhandled fallible expression (should fail)
fn unhandledFallible(x: int, y: int): nil {
    divide(x, y);  // Should fail - fallible expression not handled
}

// Test 6: Properly handled fallible expression with match
fn properlyHandled(x: int, y: int): int {
    match (divide(x, y)) {
        _ => return 0;  // Simplified pattern for now
    }
}

// Test 7: Function with generic error type
fn genericError(flag: bool): int? {
    if (flag) {
        return err(DivisionByZero);
    }
    return ok(42);
}

// Test 8: Function that can propagate from generic error
fn propagateGeneric(flag: bool): int?DivisionByZero {
    var result = genericError(flag)?;  // Should work - generic can be narrowed
    return ok(result);
}

// Test 9: Multiple error types in function signature
fn multipleErrors(x: int): int?DivisionByZero, IndexOutOfBounds {
    if (x < 0) {
        return err(DivisionByZero);
    }
    if (x > 100) {
        return err(IndexOutOfBounds);
    }
    return ok(x);
}

// Test 10: Function that handles multiple error types
fn handleMultiple(x: int): int {
    match (multipleErrors(x)) {
        _ => return 0;  // Simplified pattern for now
    }
}

// Test 11: Non-exhaustive match (should fail)
fn nonExhaustiveMatch(x: int): int {
    match (multipleErrors(x)) {
        val result => return result;
        err(DivisionByZero) => return -1;
        // Missing IndexOutOfBounds case - should fail
    }
}

// Test 12: Error construction with unknown error type (should fail)
fn unknownErrorType(): int?UnknownError {
    return err(UnknownError);  // Should fail - UnknownError not defined
}

// Test 13: Type mismatch in error union assignment
fn typeMismatch(): nil {
    var x: int?DivisionByZero = "hello";  // Should fail - string not compatible with int?DivisionByZero
}

// Test 14: Correct error union assignment
fn correctAssignment(): nil {
    var x: int?DivisionByZero = ok(42);  // Should work
    var y: int?DivisionByZero = err(DivisionByZero);  // Should work
}

// Test 15: Function call with wrong argument types
fn wrongArguments(): nil {
    divide("hello", "world");  // Should fail - string arguments not compatible with int parameters
}

// Main function to test the error handling
fn main(): nil {
    print("Testing compile-time error checking");
    
    // These should work
    var result1 = safeDivide(10, 2);
    var result2 = properlyHandled(10, 0);
    var result3 = handleMultiple(50);
    
    // Test proper error handling
    match (divide(10, 0)) {
        val result => print("Result: ", result);
        err(DivisionByZero) => print("Division by zero error");
    }
}