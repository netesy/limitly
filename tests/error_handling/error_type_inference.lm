// Test error type inference for functions using ? operator

// Helper function that can fail
fn mayFail(x: int): int?TestError {
    if (x < 0) {
        return err(TestError);
    }
    return x * 2;
}

// 1. Function that should infer error types from ? usage
fn shouldInferError(x: int): int?TestError {
    return mayFail(x)?;
}

// 2. Function that uses ? but doesn't declare error types (should cause compile error)
fn missingErrorDeclaration(x: int): int {
    return mayFail(x)?; // Should cause error: function uses ? but doesn't declare error types
}

// 3. Function that declares error types but body can't produce them (should cause error)
fn declaredButNotProduced(x: int): int?UnusedError {
    return x * 2; // Should cause error: declares UnusedError but can't produce it
}

// 4. Function that produces error types not declared (should cause error)
fn producedButNotDeclared(x: int): int?TestError {
    if (x == 0) {
        return err(AnotherError); // Should cause error: produces AnotherError but only declares TestError
    }
    return mayFail(x)?;
}

// 5. Function with correct error type inference and declaration
fn correctErrorHandling(x: int): int?TestError {
    if (x < 0) {
        return err(TestError);
    }
    return mayFail(x)?;
}

// 6. Function that calls multiple fallible functions with different error types
fn multipleErrorSources(x: int, y: str): int?TestError, ParseError {
    var parsed = parseInt(y)?; // Can produce ParseError
    var result = mayFail(x)?;  // Can produce TestError
    return result + parsed;
}

print("Testing error type inference");

// Test correct function
var result1 = correctErrorHandling(5)?else err => {
    print("Error: " + err);
    return -1;
};
print("Result 1: " + result1);

// Test multiple error sources
var result2 = multipleErrorSources(3, "42")?else err => {
    print("Error: " + err);
    return -1;
};
print("Result 2: " + result2);