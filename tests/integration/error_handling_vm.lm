// Error Handling VM Integration Tests

// Test 1: Basic error construction and checking
print("=== Test 1: Basic Error Construction ===")

// This would be generated by the compiler for error construction
// err(DivisionByZero("Cannot divide by zero"))
// For now, we'll simulate this with a simple test

var x: int = 10;
var y: int = 0;

// Test division by zero (this should eventually return an error)
if (y == 0) {
    print("Division by zero detected");
} else {
    var result: int = x / y;
    print("Result: " + result);
}

// Test 2: Success value construction
print("=== Test 2: Success Value Construction ===");

var success_value: int = 42
print("Success value: " + success_value);

// Test 3: Error propagation simulation
print("=== Test 3: Error Propagation Simulation ===");

fn divide(a: int, b: int) : int {
    if (b == 0) {
        print("Error: Division by zero in divide function");
        return -1;  // Error indicator for now
    }
    return a / b;
}

var result1: int = divide(10, 2);
print("10 / 2 = " + result1);

var result2: int = divide(10, 0);
print("10 / 0 = " + result2);

// Test 4: Nested error propagation
print("=== Test 4: Nested Error Propagation ===");

fn safe_divide(a: int, b: int) : int {
    return divide(a, b);  // This should propagate any errors from divide
}

var result3: int = safe_divide(20, 4);
print("20 / 4 = " + result3);

var result4: int = safe_divide(20, 0);
print("20 / 0 = " + result4);

// Test 5: Error handling with pattern matching simulation
print("=== Test 5: Error Handling Simulation ===");

fn handle_division(a: int, b: int) {
    if (b == 0) {
        print("Handled error: Cannot divide " + a + " by zero");
    } else {
        var result: int = a / b
        print("Division result: " + result);
    }
}

handle_division(15, 3)
handle_division(15, 0)

print("=== Error Handling VM Tests Compvare ===");