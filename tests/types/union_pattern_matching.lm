// Union Type Pattern Matching Tests
// Testing comprehensive pattern matching for union types with type checker validation

print("=== Union Type Pattern Matching Tests ===");

// Test 1: Basic union type pattern matching
print("Test 1: Basic union type pattern matching");
type NumberOrString = int | str;

var value1: NumberOrString = 42;
var value2: NumberOrString = "hello";

// Valid exhaustive pattern matching
match (value1) {
    int => print("Got integer: " + value1),
    str => print("Got string: " + value1)
}

match (value2) {
    int => print("Got integer: " + value2),
    str => print("Got string: " + value2)
}

// Test 2: Multi-variant union pattern matching
print("Test 2: Multi-variant union pattern matching");
type Color = str; // Red, Green, Blue as string aliases
type Status = str; // Active, Inactive, Pending as string aliases
type Value = int | f64 | str | bool;

var colorValue: Color = "Red";
var statusValue: Status = "Active";
var mixedValue: Value = 123;

// Pattern matching with string literals
match (colorValue) {
    "Red" => print("Color is red"),
    "Green" => print("Color is green"),
    "Blue" => print("Color is blue"),
    _ => print("Unknown color")
}

match (statusValue) {
    "Active" => print("Status is active"),
    "Inactive" => print("Status is inactive"),
    "Pending" => print("Status is pending"),
    _ => print("Unknown status")
}

// Pattern matching with type discrimination
match (mixedValue) {
    int => print("Mixed value is integer: " + mixedValue),
    f64 => print("Mixed value is float: " + mixedValue),
    str => print("Mixed value is string: " + mixedValue),
    bool => print("Mixed value is boolean: " + mixedValue)
}

// Test 3: Union type with guards
print("Test 3: Union type with guards");
type IntOrFloat = int | f64;

var numValue: IntOrFloat = 42;

match (numValue) {
    int where numValue > 10 => print("Large integer: " + numValue),
    int => print("Small integer: " + numValue),
    f64 where numValue > 10.0 => print("Large float: " + numValue),
    f64 => print("Small float: " + numValue)
}

// Test 4: Nested union types
print("Test 4: Nested union types");
type InnerUnion = int | str;
type OuterUnion = InnerUnion | bool; // Should flatten to int | str | bool

var nestedValue: OuterUnion = true;

match (nestedValue) {
    int => print("Nested value is int: " + nestedValue),
    str => print("Nested value is str: " + nestedValue),
    bool => print("Nested value is bool: " + nestedValue)
}

// Test 5: Union type with structured variants
print("Test 5: Union type with structured variants");
type Some = { kind: "Some", value: any };
type None = { kind: "None" };
type Option = Some | None;

var someValue: Option = Some { kind: "Some", value: 42 };
var noneValue: Option = None { kind: "None" };

match (someValue) {
    Some(x) => print("Got Some with value: " + x),
    None => print("Got None")
}

match (noneValue) {
    Some(x) => print("Got Some with value: " + x),
    None => print("Got None")
}

// Test 6: Union type return type inference
print("Test 6: Union type return type inference");
fn getNumberOrString(flag: bool): NumberOrString {
    if (flag) {
        return 42;
    } else {
        return "hello";
    }
}

var result = getNumberOrString(true);
match (result) {
    int => print("Function returned int: " + result),
    str => print("Function returned str: " + result)
}

// Test 7: Union type assignment compatibility
print("Test 7: Union type assignment compatibility");
type StringOrBool = str | bool;

var strBoolValue: StringOrBool;
strBoolValue = "test";  // str should be compatible with str | bool
strBoolValue = true;    // bool should be compatible with str | bool

match (strBoolValue) {
    str => print("StringOrBool is string: " + strBoolValue),
    bool => print("StringOrBool is boolean: " + strBoolValue)
}

print("=== Union Type Pattern Matching Tests Completed ===");