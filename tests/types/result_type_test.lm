// Test file for Result type functionality
// This tests the Result type as a built-in union type with error handling compatibility

// Test basic Result type usage
type IntResult = Success | Error;

// Test creating Success values
var successValue:Success ={ kind: "Success", value: 42 };
print("Success value:", successValue);

// Test creating Error values  
var errorValue:Error =  { kind: "Error", error: "Something went wrong" };
print("Error value:", errorValue);

// Test pattern matching with Result types
match (successValue) {
    Success(x) => print("Got Success with value:", x),
    Error(e) => print("Got Error:", e)
}

match (errorValue) {
    Success(x) => print("Got Success with value:", x),
    Error(e) => print("Got Error:", e)
}

// Test Result type with different value and error types
type StringIntResult = Success | Error;
var successString = Success { kind: "Success", value: "hello world" };
var errorInt = Error { kind: "Error", error: 404 };

print("String Success:", successString);
print("Int Error:", errorInt);

// Test error handling compatibility
// Result types should be compatible with the ? operator
fn maybeGetValue(): IntResult {
    return Success { kind: "Success", value: 100 };
}

fn maybeGetError(): IntResult {
    return Error { kind: "Error", error: "Network timeout" };
}

var result1 = maybeGetValue();
var result2 = maybeGetError();

print("Function result 1:", result1);
print("Function result 2:", result2);

// Test Result type with complex error types
type ParseResult = Success | Error;
var parseSuccess:Success =  { kind: "Success", value: "parsed data" };
var parseError:Error = { kind: "Error", error: "Invalid syntax at line 42" };

print("Parse success:", parseSuccess);
print("Parse error:", parseError);

// Test nested Result types
type NestedResult = Success | Error;
var nestedSuccess:Success =  { 
    kind: "Success", 
    value: Success { kind: "Success", value: "nested success" }
};
print("Nested success:", nestedSuccess);