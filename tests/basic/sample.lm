// sample.lm

// Luminar Programming Language
// Key Features:
// - Controlled Unsafe Operations

// ---------------------------------------------------
// Basic Syntax
// ---------------------------------------------------

// ---------------------------------------------------
// Core Type System
// ---------------------------------------------------

// === Primitive Types ===
type date = i64;
type numbers = u64;
type amount = f64;
type isTrue = bool;
type string = str;

// === Type Aliases ===
type Id = uint;
type Name = str;
type Age = uint;

// === Option Type ===
type SomeKind = str;
type SomeValue = any;
type Some = { kind: SomeKind, value: SomeValue };
type epty = nil;  

type Option = Some | epty;

// Example usage:
// var maybeName: Option = { kind: "Some", value: "Alice" };
// var noValue: Option = nil;

// === Result Type ===
type ResultKind = str;
type ResultValue = any;
type ResultMessage = any;
type Success = { kind: ResultKind, value: ResultValue };
type Error = { kind: ResultKind, message: ResultMessage };

type Result = Success | Error;

// Example usage:
// var res: Result = { kind: "Success", value: 42 };
// var err: Result = { kind: "Error", message: "Not found" };

// === Collection Types ===
type ListOfAny = [any];
type ListOfString = [str];
type ListOfPerson = [Person];

type DictOfAny = {any: any};
type DictOfString = {str: str};
type DictOfIntToUser = {int: User};

// === Union Types ===
type NumberType = int | f64;
type StringOrNumber = str | NumberType;

// === Refined Types ===
type PositiveInt = int where value > 0;
type EmailString = str where matches(value, "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$");
type Percentage = float where value >= 0.0 and value <= 100.0;

// === Structural Types ===
type NameType = str;
type AgeType = uint;
type HasName = { name: NameType };
type HasAge = { age: AgeType };
type Person = HasName and HasAge;

// === Extensible Structural Types ===
type StreetType = str;
type CityType = str;
type ZipType = str;
type EmailType = str;
type PhoneType = str;
type EmployeeIdType = uint;
type DepartmentType = str;
type Address = { street: StreetType, city: CityType, zipcode: ZipType };
type ContactInfo = { email: EmailType, phone: PhoneType };
type Employee = { ...Person, ...Address, ...ContactInfo, employeeId: EmployeeIdType, department: DepartmentType };
type Manager = { ...Employee, managedTeam: [Employee] };
type ExtendedRecord = { ...BaseRecord, newField: int };
type MultipleBaseRecord = { ...Base1, ...Base2, additionalField: bool };

// Arithmetic and Logical Operations
print(10 + 5 * 2);                  // Output: 20
print((10 > 5) and (5 < 2));        // false
print("Hello, " + "Luminar!");      // String concatenation


// === Loops ===

// C-style loop
for (var i = 0; i < 10; i += 1) {
    print(i);
}

// Range-based loop
iter (i in 1..5) {
    print("Range iteration: {i}");
}

// List-based loop with explicit string list type
var fruits: ListOfString = ["Apple", "Banana", "Cherry"];
iter (fruit in fruits) {
    print(fruit);
}

// Dictionary-based loop with defined key/value type
type KeyType = str;
type ValueType = int;
type DictOfStrToInt = {KeyType: ValueType};
var my_dict: DictOfStrToInt = { "a": 1, "b": 2, "c": 3 };
iter (key, value in my_dict) {
    print("{key}: {value}");
}

// Nested loop
iter (x in 1..3) {
    iter (y in 1..2) {
        print("x: {x}, y: {y}");
    }
}

// While loop
var count: int = 0;
while (count < 3) {
    print("Count: {count}");
    count += 1;
}

// === Traits (Interfaces) ===


// === I/O Operations ===

/// Writes string content to a file.
fn write_to_file(filename: str, content: str) {
 //   var file = open(filename, "write");
 //   file.write(content);
 //   file.close();
 print("File written successfully.");
}

/// Reads full contents of a file. Returns `Option`.
fn read_from_file(filename: str): Option {
 //   var file = open(filename, "read");
 //   var content = file.read_all();
 //   file.close();
 print("File read successfully.");
 //   return { kind: Some, value: content };
}

// === Modules ===

//@private: Accessible only within the file.
//@protected: Accessible within the module but not externally.

module MathUtils {
    @public
    fn add(a: int, b: int): int {
        return a + b;
    }

    @public
    fn subtract(a: int, b: int): int {
        return a - b;
    }

    fn factorial(n: int): int {
        if (n <= 1) { return 1; }
        return n * factorial(n - 1);
    }
}

import MathUtils;
print(MathUtils.add(5, 3));         // Output: 8
// print(MathUtils.factorial(4));   // Not public, won't compile



// === Function Contracts ===

/// Square root function with pre- and post-conditions.
fn sqrt(x: amount): amount {
    contract(x >= 0, "Cannot compute sqrt of negative number");
    var result = x ** 0.5;
    contract(result >= 0, "Result must be non-negative");
    return result;
}

// === Class Contracts ===

/// A simple bank account class enforcing invariant rules.
class BankAccount {
    var balance: amount;

    BankAccount(initial_balance: amount) {
        contract(initial_balance >= 0, "Initial balance cannot be negative");
        self.balance = initial_balance;
    }

    fn deposit(amount: amount) {
        contract(amount > 0, "Deposit amount must be positive");
        self.balance += amount;
    }

    fn withdraw(amount: amount) {
        contract(amount > 0, "Withdrawal amount must be positive");
        contract(self.balance >= amount, "Insufficient funds");
        self.balance -= amount;
    }
}
