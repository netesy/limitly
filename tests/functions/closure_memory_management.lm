# Closure Memory Management Test
# Tests closure variable lifetime tracking, cleanup, and circular reference detection

print("=== Closure Memory Management Tests ===");

# Test 1: Basic closure creation and cleanup
print("\n--- Test 1: Basic Closure Creation ---");
fn createSimpleClosure() -> fn(int) -> int {
    let x: int = 42;
    return fn(y: int) -> int {
        return x + y;
    };
}

let simpleClosure = createSimpleClosure();
let result1 = simpleClosure(8);
print("Simple closure result: " + result1); # Should be 50

# Test 2: Closure with multiple captured variables
print("\n--- Test 2: Multiple Captured Variables ---");
fn createMultiVarClosure() -> fn(int) -> int {
    let a: int = 10;
    let b: int = 20;
    let c: int = 30;
    return fn(x: int) -> int {
        return a + b + c + x;
    };
}

let multiVarClosure = createMultiVarClosure();
let result2 = multiVarClosure(5);
print("Multi-variable closure result: " + result2); # Should be 65

# Test 3: Nested closures (potential for circular references)
print("\n--- Test 3: Nested Closures ---");
fn createNestedClosure() -> fn(int) -> fn(int) -> int {
    let outer: int = 100;
    return fn(middle: int) -> fn(int) -> int {
        let combined: int = outer + middle;
        return fn(inner: int) -> int {
            return combined + inner;
        };
    };
}

let nestedClosure = createNestedClosure();
let innerClosure = nestedClosure(50);
let result3 = innerClosure(25);
print("Nested closure result: " + result3); # Should be 175

# Test 4: Closure variable modification
print("\n--- Test 4: Closure Variable Modification ---");
fn createModifyingClosure() -> fn() -> int {
    let counter: int = 0;
    return fn() -> int {
        counter = counter + 1;
        return counter;
    };
}

let counterClosure = createModifyingClosure();
print("Counter 1: " + counterClosure()); # Should be 1
print("Counter 2: " + counterClosure()); # Should be 2
print("Counter 3: " + counterClosure()); # Should be 3

# Test 5: Multiple closures sharing variables (memory optimization test)
print("\n--- Test 5: Shared Variable Optimization ---");
fn createSharedVarClosures() -> (fn(int) -> int, fn(int) -> int) {
    let shared: int = 1000;
    let closure1 = fn(x: int) -> int {
        return shared + x;
    };
    let closure2 = fn(y: int) -> int {
        return shared * y;
    };
    return (closure1, closure2);
}

let (sharedClosure1, sharedClosure2) = createSharedVarClosures();
print("Shared closure 1: " + sharedClosure1(5)); # Should be 1005
print("Shared closure 2: " + sharedClosure2(3)); # Should be 3000

# Test 6: Closure cleanup test (creating many closures)
print("\n--- Test 6: Closure Cleanup Test ---");
fn createManyClosures() {
    iter (i in 1..10) {
        let localVar: int = i * 10;
        let tempClosure = fn(x: int) -> int {
            return localVar + x;
        };
        # These closures should be cleaned up when they go out of scope
        let tempResult = tempClosure(i);
        print("Temp closure " + i + " result: " + tempResult);
    }
}

createManyClosures();

# Test 7: Closure with captured closure (circular reference test)
print("\n--- Test 7: Circular Reference Test ---");
fn createCircularTest() -> fn(int) -> int {
    let value: int = 42;
    let innerClosure = fn(x: int) -> int {
        return value + x;
    };
    
    # This closure captures another closure
    let outerClosure = fn(y: int) -> int {
        let innerResult = innerClosure(y);
        return innerResult * 2;
    };
    
    return outerClosure;
}

let circularClosure = createCircularTest();
let result7 = circularClosure(8);
print("Circular reference test result: " + result7); # Should be 100

print("\n=== All Closure Memory Management Tests Complete ===");