=== Phase 1: Type Checking ===
[1m[31merror[0m[1m[E200][0m[1m[SemanticError][0m[1m: [0mUse after move: variable 'source' was moved and is no longer accessible [BugCauseMitigation: Linear types, regions, lifetime checks]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m9[0m
[90m   |[0m
 7[34m â”‚ [0mvar source: int = 100;
 8[34m â”‚ [0mvar target: int = source;  // source is moved
 9[31m â†’ [0mprint(source);  // ERROR: Use after move
10[34m â”‚ [0m
11[34m â”‚ [0m// Test 2: Use before initialization

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E201][0m[1m[SemanticError][0m[1m: [0mDangling pointer: variable 'source' points to invalid memory [BugCauseMitigation: Region + generational references]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m9[0m
[90m   |[0m
 7[34m â”‚ [0mvar source: int = 100;
 8[34m â”‚ [0mvar target: int = source;  // source is moved
 9[31m â†’ [0mprint(source);  // ERROR: Use after move
10[34m â”‚ [0m
11[34m â”‚ [0m// Test 2: Use before initialization

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E202][0m[1m[SemanticError][0m[1m: [0mUse before initialization: variable 'uninitialized' is used before being initialized [BugCauseMitigation: Require initialization, zero-fill debug]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m13[0m
[90m   |[0m
11[34m â”‚ [0m// Test 2: Use before initialization
12[34m â”‚ [0mvar uninitialized: int;
13[31m â†’ [0mprint(uninitialized);  // ERROR: Use before initialization
14[34m â”‚ [0m
15[34m â”‚ [0m// Test 3: Double move

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E203][0m[1m[SemanticError][0m[1m: [0mUninitialized use: variable 'uninitialized' used before initialization [BugCauseMitigation: Require initialization, zero-fill debug]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m13[0m
[90m   |[0m
11[34m â”‚ [0m// Test 2: Use before initialization
12[34m â”‚ [0mvar uninitialized: int;
13[31m â†’ [0mprint(uninitialized);  // ERROR: Use before initialization
14[34m â”‚ [0m
15[34m â”‚ [0m// Test 3: Double move

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E204][0m[1m[SemanticError][0m[1m: [0mUse after move: variable 'original' was moved and is no longer accessible [BugCauseMitigation: Linear types, regions, lifetime checks]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m18[0m
[90m   |[0m
16[34m â”‚ [0mvar original: int = 200;
17[34m â”‚ [0mvar first_move: int = original;   // original is moved
18[31m â†’ [0mvar second_move: int = original;  // ERROR: Double move
19[34m â”‚ [0m
20[34m â”‚ [0m// Test 4: Use after scope ends

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E205][0m[1m[SemanticError][0m[1m: [0mDangling pointer: variable 'original' points to invalid memory [BugCauseMitigation: Region + generational references]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m18[0m
[90m   |[0m
16[34m â”‚ [0mvar original: int = 200;
17[34m â”‚ [0mvar first_move: int = original;   // original is moved
18[31m â†’ [0mvar second_move: int = original;  // ERROR: Double move
19[34m â”‚ [0m
20[34m â”‚ [0m// Test 4: Use after scope ends

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E206][0m[1m[SemanticError][0m[1m: [0mDouble move: variable 'original' was already moved
[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[31merror[0m[1m[E207][0m[1m[SemanticError][0m[1m: [0mUse after move: variable 'linear_value' was moved and is no longer accessible [BugCauseMitigation: Linear types, regions, lifetime checks]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m31[0m
[90m   |[0m
29[34m â”‚ [0mvar linear_value: int = 400;
30[34m â”‚ [0mvar reference = linear_value;  // Creates reference
31[31m â†’ [0mvar moved_value: int = linear_value;  // linear_value is moved, invalidating reference
32[34m â”‚ [0mprint(reference);  // ERROR: Reference to moved value
33[34m â”‚ [0m

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E208][0m[1m[SemanticError][0m[1m: [0mDangling pointer: variable 'linear_value' points to invalid memory [BugCauseMitigation: Region + generational references]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m31[0m
[90m   |[0m
29[34m â”‚ [0mvar linear_value: int = 400;
30[34m â”‚ [0mvar reference = linear_value;  // Creates reference
31[31m â†’ [0mvar moved_value: int = linear_value;  // linear_value is moved, invalidating reference
32[34m â”‚ [0mprint(reference);  // ERROR: Reference to moved value
33[34m â”‚ [0m

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E209][0m[1m[SemanticError][0m[1m: [0mDouble move: variable 'linear_value' was already moved
[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[31merror[0m[1m[E210][0m[1m[SemanticError][0m[1m: [0mUse before initialization: variable 'uninit_a' is used before being initialized [BugCauseMitigation: Require initialization, zero-fill debug]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m98[0m
[90m   |[0m
 96[34m â”‚ [0mvar uninit_a: int;
 97[34m â”‚ [0mvar uninit_b: int;
 98[31m â†’ [0mvar result: int = uninit_a + uninit_b;  // ERROR: Use of uninitialized variables
 99[34m â”‚ [0m
100[34m â”‚ [0m// Test 17: Move in loop causing issues

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E211][0m[1m[SemanticError][0m[1m: [0mUninitialized use: variable 'uninit_a' used before initialization [BugCauseMitigation: Require initialization, zero-fill debug]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m98[0m
[90m   |[0m
 96[34m â”‚ [0mvar uninit_a: int;
 97[34m â”‚ [0mvar uninit_b: int;
 98[31m â†’ [0mvar result: int = uninit_a + uninit_b;  // ERROR: Use of uninitialized variables
 99[34m â”‚ [0m
100[34m â”‚ [0m// Test 17: Move in loop causing issues

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E212][0m[1m[SemanticError][0m[1m: [0mUse before initialization: variable 'uninit_b' is used before being initialized [BugCauseMitigation: Require initialization, zero-fill debug]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m98[0m
[90m   |[0m
 96[34m â”‚ [0mvar uninit_a: int;
 97[34m â”‚ [0mvar uninit_b: int;
 98[31m â†’ [0mvar result: int = uninit_a + uninit_b;  // ERROR: Use of uninitialized variables
 99[34m â”‚ [0m
100[34m â”‚ [0m// Test 17: Move in loop causing issues

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

[1m[31merror[0m[1m[E213][0m[1m[SemanticError][0m[1m: [0mUninitialized use: variable 'uninit_b' used before initialization [BugCauseMitigation: Require initialization, zero-fill debug]
[34m--> [0m[34mtests\memory\memory_error_tests.lm[0m[34m:[0m[34m98[0m
[90m   |[0m
 96[34m â”‚ [0mvar uninit_a: int;
 97[34m â”‚ [0mvar uninit_b: int;
 98[31m â†’ [0mvar result: int = uninit_a + uninit_b;  // ERROR: Use of uninitialized variables
 99[34m â”‚ [0m
100[34m â”‚ [0m// Test 17: Move in loop causing issues

[1m[33mHint: [0mLanguage feature: Variables in Limit are declared with 'var name: type = value;' Type annotations are optional when the type can be inferred.

[1m[34mFile: [0m[34mtests\memory\memory_error_tests.lm[0m

Type checking errors:
